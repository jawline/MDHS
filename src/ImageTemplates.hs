module ImageTemplates where
import System.FilePath
import System.Directory
import Data.Char (toLower)
import Graphics.Image
import Util (dedup, if', splitAt')
import Templates (rewriteTemplates, defaultExtractTemplateString)

-- Data type represents the possible transformations for a source image.
data ExpectedSize = Original
  | Fixed Int Int
  | Scaled Float
  | ScaledToWidth Float
  | ScaledToHeight Float
  | QualityThumb
  | QualityHigh
  deriving (Show, Eq)

-- An image 'expectation' includes the expected filename and dimensions or scaling factor
data ImageExpectation = ImageExpectation {
  name :: String,
  fileType :: String,
  size :: ExpectedSize
} deriving (Show, Eq)

-- Character substitutions to go from an expectation to its filename when being translated
substitutes :: Char -> Char
substitutes ' ' = '_'
substitutes '.' = '_'
substitutes x = toLower x

imageExpectationFilename :: ImageExpectation -> FilePath
imageExpectationFilename expectation = ((name expectation) ++ "_" ++ (Prelude.map substitutes (show (size expectation)))) <.> (fileType expectation)

-- Round floating dimensions to integers
roundDims (a, b) = (round a, round b)

-- Scale a integer dimension pair by a scalar
scaleBy (a, b) scalar = roundDims (((fromIntegral a) * scalar), ((fromIntegral b) * scalar))

-- Convert integral dimension to floating dimensions
toFloating (a, b) = (fromIntegral a, fromIntegral b)

minArea (w1, h1) (w2, h2) = if' ((w1 * h1) > (w2 * h2)) (w2, h2) (w1, h1)

-- Make the largest edge of dims be maxEdge wide
makeLargestEdge maxEdge dims = minArea scaledWidth scaledHeight
  where
    scaledWidth = decideShape dims (ScaledToWidth maxEdge)
    scaledHeight = decideShape dims (ScaledToHeight maxEdge)

-- Given the current dimensions and the expected shape calculate the new dimensions
decideShape (a, b) (Fixed x y) = (x, y)
decideShape (a, b) (Scaled x) = roundDims (a' * x, b' * x)
  where (a', b') = toFloating (a, b)
decideShape (a, b) (ScaledToWidth x) = scaleBy (a, b) scalar
  where
    scalar = x / (fromIntegral a)
decideShape (a, b) (ScaledToHeight x) = scaleBy (a, b) scalar
  where
    scalar = x / (fromIntegral b)
decideShape dims QualityThumb = makeLargestEdge 100 dims
decideShape dims QualityHigh = makeLargestEdge 300 dims

-- Transforms a given file expectation (and source file) to a output image
transformExpectation :: FilePath -> FilePath -> ImageExpectation -> IO ()
transformExpectation imageRoot outputDir expectation = do
  let filename = outputDir </> (imageExpectationFilename expectation)
  putStrLn $ "[+] Transforming " ++ filename
  file <- readImageRGBA VU (imageRoot </> (name expectation) <.> (fileType expectation))
  let newDims = decideShape (dims file) (size expectation)
  writeImage filename $ resize Bilinear Edge newDims file
  return ()

-- Transforms a set of source files into web optimized files using expectations generated by finding the image template strings in markdown files, stopping unused files ending up in the build and automatically converting them to desired resolutions.
transformImages :: FilePath -> FilePath -> [ImageExpectation] -> IO ()
transformImages imageSource imageDest expectations = do
  mapM_ (\x -> transformExpectation imageSource imageDest x) (dedup expectations)
  return ()

-- If the string is at the start of an image template string then return the start of the image template string content
-- I.e, if ${{{img:hello} return hello}
-- Return Nothing if not the start of an image template string
imgTemplateStart :: String -> Maybe String
imgTemplateStart ('$':'{':'{':'{':'i':'m':'g':':':xs) = Just xs
imgTemplateStart _ = Nothing

-- Separate the name and extension of the target image
nameAndType :: String -> (String, String)
nameAndType filePath = (dropExtension filePath, takeExtension filePath)

-- Rewrite a file path and expected size into an image expectation
imgTemplateRewriteBase hostedImagesPath filepath size = Just (localPath, [expectation])
  where
    (name, fileType) = nameAndType filepath
    expectation = ImageExpectation { name=name, fileType=fileType, size=size }
    localPath = hostedImagesPath </> (imageExpectationFilename expectation)

-- If "original" or "thumb" select those sizes otherwise default to High
matchStrToFilesize "original" = Original
matchStrToFilesize "thumb" = QualityThumb
matchStrToFilesize _ = QualityHigh

-- Rewrite an image template string into a hosted image path (like /images/file.png) and an image expectation for the image processor
imgTemplateRewriter :: String -> String -> Maybe (String, [ImageExpectation])
imgTemplateRewriter hostedImagesPath templateString =
  imgTemplateRewriteBase hostedImagesPath namePart (matchStrToFilesize sizePart)
  where
    (namePart, sizePart) = splitAt' ':' templateString

-- Rewrite all of the image templates in a source and return a list of image expectations for later processing
rewriteImageTemplates :: String -> String -> (String, [ImageExpectation])
rewriteImageTemplates hostedImagesPath source = rewriteTemplates imgTemplateStart defaultExtractTemplateString (imgTemplateRewriter hostedImagesPath) source
